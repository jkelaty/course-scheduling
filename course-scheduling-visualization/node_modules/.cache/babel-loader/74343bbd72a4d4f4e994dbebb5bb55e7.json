{"ast":null,"code":"/**\n * The main bootstrap script for loading pyodide.\n */\nexport var languagePluginLoader = new Promise((resolve, reject) => {\n  // This is filled in by the Makefile to be either a local file or the\n  // deployed location. TODO: This should be done in a less hacky\n  // way.\n  var baseURL = self.languagePluginUrl || 'https://pyodide.cdn.iodide.io/';\n  baseURL = baseURL.substr(0, baseURL.lastIndexOf('/')) + '/'; ////////////////////////////////////////////////////////////\n  // Package loading\n\n  let loadedPackages = new Array();\n  var loadPackagePromise = new Promise(resolve => resolve()); // Regexp for validating package name and URI\n\n  var package_name_regexp = '[a-z0-9_][a-z0-9_\\-]*';\n  var package_uri_regexp = new RegExp('^https?://.*?(' + package_name_regexp + ').js$', 'i');\n  var package_name_regexp = new RegExp('^' + package_name_regexp + '$', 'i');\n\n  let _uri_to_package_name = package_uri => {\n    // Generate a unique package name from URI\n    if (package_name_regexp.test(package_uri)) {\n      return package_uri;\n    } else if (package_uri_regexp.test(package_uri)) {\n      let match = package_uri_regexp.exec(package_uri); // Get the regexp group corresponding to the package name\n\n      return match[1];\n    } else {\n      return null;\n    }\n  }; // clang-format off\n\n\n  let preloadWasm = () => {\n    // On Chrome, we have to instantiate wasm asynchronously. Since that\n    // can't be done synchronously within the call to dlopen, we instantiate\n    // every .so that comes our way up front, caching it in the\n    // `preloadedWasm` dictionary.\n    let promise = new Promise(resolve => resolve());\n    let FS = pyodide._module.FS;\n\n    function recurseDir(rootpath) {\n      let dirs;\n\n      try {\n        dirs = FS.readdir(rootpath);\n      } catch {\n        return;\n      }\n\n      for (let entry of dirs) {\n        if (entry.startsWith('.')) {\n          continue;\n        }\n\n        const path = rootpath + entry;\n\n        if (entry.endsWith('.so')) {\n          if (Module['preloadedWasm'][path] === undefined) {\n            promise = promise.then(() => Module['loadWebAssemblyModule'](FS.readFile(path), {\n              loadAsync: true\n            })).then(module => {\n              Module['preloadedWasm'][path] = module;\n            });\n          }\n        } else if (FS.isDir(FS.lookupPath(path).node.mode)) {\n          recurseDir(path + '/');\n        }\n      }\n    }\n\n    recurseDir('/');\n    return promise;\n  }; // clang-format on\n\n\n  function loadScript(url, onload, onerror) {\n    if (self.document) {\n      // browser\n      const script = self.document.createElement('script');\n      script.src = url;\n\n      script.onload = e => {\n        onload();\n      };\n\n      script.onerror = e => {\n        onerror();\n      };\n\n      self.document.head.appendChild(script);\n    } else if (self.importScripts) {\n      // webworker\n      try {\n        self.importScripts(url);\n        onload();\n      } catch {\n        onerror();\n      }\n    }\n  }\n\n  let _loadPackage = (names, messageCallback) => {\n    // DFS to find all dependencies of the requested packages\n    let packages = self.pyodide._module.packages.dependencies;\n    let loadedPackages = self.pyodide.loadedPackages;\n    let queue = [].concat(names || []);\n    let toLoad = new Array();\n\n    while (queue.length) {\n      let package_uri = queue.pop();\n\n      const pkg = _uri_to_package_name(package_uri);\n\n      if (pkg == null) {\n        console.error(`Invalid package name or URI '${package_uri}'`);\n        return;\n      } else if (pkg == package_uri) {\n        package_uri = 'default channel';\n      }\n\n      if (pkg in loadedPackages) {\n        if (package_uri != loadedPackages[pkg]) {\n          console.error(`URI mismatch, attempting to load package ` + `${pkg} from ${package_uri} while it is already ` + `loaded from ${loadedPackages[pkg]}!`);\n          return;\n        }\n      } else if (pkg in toLoad) {\n        if (package_uri != toLoad[pkg]) {\n          console.error(`URI mismatch, attempting to load package ` + `${pkg} from ${package_uri} while it is already ` + `being loaded from ${toLoad[pkg]}!`);\n          return;\n        }\n      } else {\n        console.log(`Loading ${pkg} from ${package_uri}`);\n        toLoad[pkg] = package_uri;\n\n        if (packages.hasOwnProperty(pkg)) {\n          packages[pkg].forEach(subpackage => {\n            if (!(subpackage in loadedPackages) && !(subpackage in toLoad)) {\n              queue.push(subpackage);\n            }\n          });\n        } else {\n          console.error(`Unknown package '${pkg}'`);\n        }\n      }\n    }\n\n    self.pyodide._module.locateFile = path => {\n      // handle packages loaded from custom URLs\n      let pkg = path.replace(/\\.data$/, \"\");\n\n      if (pkg in toLoad) {\n        let package_uri = toLoad[pkg];\n\n        if (package_uri != 'default channel') {\n          return package_uri.replace(/\\.js$/, \".data\");\n        }\n\n        ;\n      }\n\n      ;\n      return baseURL + path;\n    };\n\n    let promise = new Promise((resolve, reject) => {\n      if (Object.keys(toLoad).length === 0) {\n        resolve('No new packages to load');\n        return;\n      }\n\n      const packageList = Array.from(Object.keys(toLoad)).join(', ');\n\n      if (messageCallback !== undefined) {\n        messageCallback(`Loading ${packageList}`);\n      } // monitorRunDependencies is called at the beginning and the end of each\n      // package being loaded. We know we are done when it has been called\n      // exactly \"toLoad * 2\" times.\n\n\n      var packageCounter = Object.keys(toLoad).length * 2;\n\n      self.pyodide._module.monitorRunDependencies = () => {\n        packageCounter--;\n\n        if (packageCounter === 0) {\n          for (let pkg in toLoad) {\n            self.pyodide.loadedPackages[pkg] = toLoad[pkg];\n          }\n\n          delete self.pyodide._module.monitorRunDependencies;\n          self.removeEventListener('error', windowErrorHandler);\n\n          if (!isFirefox) {\n            preloadWasm().then(() => {\n              resolve(`Loaded ${packageList}`);\n            });\n          } else {\n            resolve(`Loaded ${packageList}`);\n          }\n        }\n      }; // Add a handler for any exceptions that are thrown in the process of\n      // loading a package\n\n\n      var windowErrorHandler = err => {\n        delete self.pyodide._module.monitorRunDependencies;\n        self.removeEventListener('error', windowErrorHandler); // Set up a new Promise chain, since this one failed\n\n        loadPackagePromise = new Promise(resolve => resolve());\n        reject(err.message);\n      };\n\n      self.addEventListener('error', windowErrorHandler);\n\n      for (let pkg in toLoad) {\n        let scriptSrc;\n        let package_uri = toLoad[pkg];\n\n        if (package_uri == 'default channel') {\n          scriptSrc = `${baseURL}${pkg}.js`;\n        } else {\n          scriptSrc = `${package_uri}`;\n        }\n\n        loadScript(scriptSrc, () => {}, () => {\n          // If the package_uri fails to load, call monitorRunDependencies twice\n          // (so packageCounter will still hit 0 and finish loading), and remove\n          // the package from toLoad so we don't mark it as loaded.\n          console.error(`Couldn't load package from URL ${scriptSrc}`);\n          let index = toLoad.indexOf(pkg);\n\n          if (index !== -1) {\n            toLoad.splice(index, 1);\n          }\n\n          for (let i = 0; i < 2; i++) {\n            self.pyodide._module.monitorRunDependencies();\n          }\n        });\n      } // We have to invalidate Python's import caches, or it won't\n      // see the new files. This is done here so it happens in parallel\n      // with the fetching over the network.\n\n\n      self.pyodide.runPython('import importlib as _importlib\\n' + '_importlib.invalidate_caches()\\n');\n    });\n    return promise;\n  };\n\n  let loadPackage = (names, messageCallback) => {\n    /* We want to make sure that only one loadPackage invocation runs at any\n     * given time, so this creates a \"chain\" of promises. */\n    loadPackagePromise = loadPackagePromise.then(() => _loadPackage(names, messageCallback));\n    return loadPackagePromise;\n  }; ////////////////////////////////////////////////////////////\n  // Fix Python recursion limit\n\n\n  function fixRecursionLimit(pyodide) {\n    // The Javascript/Wasm call stack may be too small to handle the default\n    // Python call stack limit of 1000 frames. This is generally the case on\n    // Chrom(ium), but not on Firefox. Here, we determine the Javascript call\n    // stack depth available, and then divide by 50 (determined heuristically)\n    // to set the maximum Python call stack depth.\n    let depth = 0;\n\n    function recurse() {\n      depth += 1;\n      recurse();\n    }\n\n    try {\n      recurse();\n    } catch (err) {\n      ;\n    }\n\n    let recursionLimit = depth / 50;\n\n    if (recursionLimit > 1000) {\n      recursionLimit = 1000;\n    }\n\n    pyodide.runPython(`import sys; sys.setrecursionlimit(int(${recursionLimit}))`);\n  }\n\n  ; ////////////////////////////////////////////////////////////\n  // Rearrange namespace for public API\n\n  let PUBLIC_API = ['globals', 'loadPackage', 'loadedPackages', 'pyimport', 'repr', 'runPython', 'runPythonAsync', 'checkABI', 'version', 'autocomplete'];\n\n  function makePublicAPI(module, public_api) {\n    var namespace = {\n      _module: module\n    };\n\n    for (let name of public_api) {\n      namespace[name] = module[name];\n    }\n\n    return namespace;\n  } ////////////////////////////////////////////////////////////\n  // Loading Pyodide\n\n\n  let wasmURL = `${baseURL}pyodide.asm.wasm`;\n  let Module = {};\n  self.Module = Module;\n  Module.noImageDecoding = true;\n  Module.noAudioDecoding = true;\n  Module.noWasmDecoding = true;\n  Module.preloadedWasm = {};\n  let isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n  let wasm_promise;\n\n  if (WebAssembly.compileStreaming === undefined) {\n    wasm_promise = fetch(wasmURL).then(response => response.arrayBuffer()).then(bytes => WebAssembly.compile(bytes));\n  } else {\n    wasm_promise = WebAssembly.compileStreaming(fetch(wasmURL));\n  }\n\n  Module.instantiateWasm = (info, receiveInstance) => {\n    wasm_promise.then(module => WebAssembly.instantiate(module, info)).then(instance => receiveInstance(instance));\n    return {};\n  };\n\n  Module.checkABI = function (ABI_number) {\n    if (ABI_number !== parseInt('1')) {\n      var ABI_mismatch_exception = `ABI numbers differ. Expected 1, got ${ABI_number}`;\n      console.error(ABI_mismatch_exception);\n      throw ABI_mismatch_exception;\n    }\n\n    return true;\n  };\n\n  Module.autocomplete = function (path) {\n    var pyodide_module = Module.pyimport(\"pyodide\");\n    return pyodide_module.get_completions(path);\n  };\n\n  Module.locateFile = path => baseURL + path;\n\n  var postRunPromise = new Promise((resolve, reject) => {\n    Module.postRun = () => {\n      delete self.Module;\n      fetch(`${baseURL}packages.json`).then(response => response.json()).then(json => {\n        fixRecursionLimit(self.pyodide);\n        self.pyodide.globals = self.pyodide.runPython('import sys\\nsys.modules[\"__main__\"]');\n        self.pyodide = makePublicAPI(self.pyodide, PUBLIC_API);\n        self.pyodide._module.packages = json;\n\n        if (self.iodide !== undefined) {\n          // Perform some completions immediately so there isn't a delay on\n          // the first call to autocomplete\n          self.pyodide.runPython('import pyodide');\n          self.pyodide.runPython('pyodide.get_completions(\"\")');\n        }\n\n        resolve();\n      });\n    };\n  });\n  var dataLoadPromise = new Promise((resolve, reject) => {\n    Module.monitorRunDependencies = n => {\n      if (n === 0) {\n        delete Module.monitorRunDependencies;\n        resolve();\n      }\n    };\n  });\n  Promise.all([postRunPromise, dataLoadPromise]).then(() => resolve());\n  const data_script_src = `${baseURL}pyodide.asm.data.js`;\n  loadScript(data_script_src, () => {\n    const scriptSrc = `${baseURL}pyodide.asm.js`;\n    loadScript(scriptSrc, () => {\n      // The emscripten module needs to be at this location for the core\n      // filesystem to install itself. Once that's complete, it will be replaced\n      // by the call to `makePublicAPI` with a more limited public API.\n      self.pyodide = pyodide(Module);\n      self.pyodide.loadedPackages = new Array();\n      self.pyodide.loadPackage = loadPackage;\n    }, () => {});\n  }, () => {}); ////////////////////////////////////////////////////////////\n  // Iodide-specific functionality, that doesn't make sense\n  // if not using with Iodide.\n\n  if (self.iodide !== undefined) {\n    // Load the custom CSS for Pyodide\n    let link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.type = 'text/css';\n    link.href = `${baseURL}renderedhtml.css`;\n    document.getElementsByTagName('head')[0].appendChild(link); // Add a custom output handler for Python objects\n\n    self.iodide.addOutputRenderer({\n      shouldRender: val => {\n        return typeof val === 'function' && pyodide._module.PyProxy.isPyProxy(val);\n      },\n      render: val => {\n        let div = document.createElement('div');\n        div.className = 'rendered_html';\n        var element;\n\n        if (val._repr_html_ !== undefined) {\n          let result = val._repr_html_();\n\n          if (typeof result === 'string') {\n            div.appendChild(new DOMParser().parseFromString(result, 'text/html').body.firstChild);\n            element = div;\n          } else {\n            element = result;\n          }\n        } else {\n          let pre = document.createElement('pre');\n          pre.textContent = val.toString();\n          div.appendChild(pre);\n          element = div;\n        }\n\n        return element.outerHTML;\n      }\n    });\n  }\n});\nlanguagePluginLoader;","map":{"version":3,"sources":["/Users/jkelaty/Desktop/course-scheduling/course-scheduling/src/pyodide/pyodide.js"],"names":["languagePluginLoader","Promise","resolve","reject","baseURL","self","languagePluginUrl","substr","lastIndexOf","loadedPackages","Array","loadPackagePromise","package_name_regexp","package_uri_regexp","RegExp","_uri_to_package_name","package_uri","test","match","exec","preloadWasm","promise","FS","pyodide","_module","recurseDir","rootpath","dirs","readdir","entry","startsWith","path","endsWith","Module","undefined","then","readFile","loadAsync","module","isDir","lookupPath","node","mode","loadScript","url","onload","onerror","document","script","createElement","src","e","head","appendChild","importScripts","_loadPackage","names","messageCallback","packages","dependencies","queue","concat","toLoad","length","pop","pkg","console","error","log","hasOwnProperty","forEach","subpackage","push","locateFile","replace","Object","keys","packageList","from","join","packageCounter","monitorRunDependencies","removeEventListener","windowErrorHandler","isFirefox","err","message","addEventListener","scriptSrc","index","indexOf","splice","i","runPython","loadPackage","fixRecursionLimit","depth","recurse","recursionLimit","PUBLIC_API","makePublicAPI","public_api","namespace","name","wasmURL","noImageDecoding","noAudioDecoding","noWasmDecoding","preloadedWasm","navigator","userAgent","toLowerCase","wasm_promise","WebAssembly","compileStreaming","fetch","response","arrayBuffer","bytes","compile","instantiateWasm","info","receiveInstance","instantiate","instance","checkABI","ABI_number","parseInt","ABI_mismatch_exception","autocomplete","pyodide_module","pyimport","get_completions","postRunPromise","postRun","json","globals","iodide","dataLoadPromise","n","all","data_script_src","link","rel","type","href","getElementsByTagName","addOutputRenderer","shouldRender","val","PyProxy","isPyProxy","render","div","className","element","_repr_html_","result","DOMParser","parseFromString","body","firstChild","pre","textContent","toString","outerHTML"],"mappings":"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","sourcesContent":["/**\n * The main bootstrap script for loading pyodide.\n */\n\nexport var languagePluginLoader = new Promise((resolve, reject) => {\n  // This is filled in by the Makefile to be either a local file or the\n  // deployed location. TODO: This should be done in a less hacky\n  // way.\n  var baseURL = self.languagePluginUrl || 'https://pyodide.cdn.iodide.io/';\n  baseURL = baseURL.substr(0, baseURL.lastIndexOf('/')) + '/';\n\n  ////////////////////////////////////////////////////////////\n  // Package loading\n  let loadedPackages = new Array();\n  var loadPackagePromise = new Promise((resolve) => resolve());\n  // Regexp for validating package name and URI\n  var package_name_regexp = '[a-z0-9_][a-z0-9_\\-]*'\n  var package_uri_regexp =\n      new RegExp('^https?://.*?(' + package_name_regexp + ').js$', 'i');\n  var package_name_regexp = new RegExp('^' + package_name_regexp + '$', 'i');\n\n  let _uri_to_package_name = (package_uri) => {\n    // Generate a unique package name from URI\n\n    if (package_name_regexp.test(package_uri)) {\n      return package_uri;\n    } else if (package_uri_regexp.test(package_uri)) {\n      let match = package_uri_regexp.exec(package_uri);\n      // Get the regexp group corresponding to the package name\n      return match[1];\n    } else {\n      return null;\n    }\n  };\n\n  // clang-format off\n  let preloadWasm = () => {\n    // On Chrome, we have to instantiate wasm asynchronously. Since that\n    // can't be done synchronously within the call to dlopen, we instantiate\n    // every .so that comes our way up front, caching it in the\n    // `preloadedWasm` dictionary.\n\n    let promise = new Promise((resolve) => resolve());\n    let FS = pyodide._module.FS;\n\n    function recurseDir(rootpath) {\n      let dirs;\n      try {\n        dirs = FS.readdir(rootpath);\n      } catch {\n        return;\n      }\n      for (let entry of dirs) {\n        if (entry.startsWith('.')) {\n          continue;\n        }\n        const path = rootpath + entry;\n        if (entry.endsWith('.so')) {\n          if (Module['preloadedWasm'][path] === undefined) {\n            promise = promise\n              .then(() => Module['loadWebAssemblyModule'](\n                FS.readFile(path), {loadAsync: true}))\n              .then((module) => {\n                Module['preloadedWasm'][path] = module;\n              });\n          }\n        } else if (FS.isDir(FS.lookupPath(path).node.mode)) {\n          recurseDir(path + '/');\n        }\n      }\n    }\n\n    recurseDir('/');\n\n    return promise;\n  }\n  // clang-format on\n\n  function loadScript(url, onload, onerror) {\n    if (self.document) { // browser\n      const script = self.document.createElement('script');\n      script.src = url;\n      script.onload = (e) => { onload(); };\n      script.onerror = (e) => { onerror(); };\n      self.document.head.appendChild(script);\n    } else if (self.importScripts) { // webworker\n      try {\n        self.importScripts(url);\n        onload();\n      } catch {\n        onerror();\n      }\n    }\n  }\n\n  let _loadPackage = (names, messageCallback) => {\n    // DFS to find all dependencies of the requested packages\n    let packages = self.pyodide._module.packages.dependencies;\n    let loadedPackages = self.pyodide.loadedPackages;\n    let queue = [].concat(names || []);\n    let toLoad = new Array();\n    while (queue.length) {\n      let package_uri = queue.pop();\n\n      const pkg = _uri_to_package_name(package_uri);\n\n      if (pkg == null) {\n        console.error(`Invalid package name or URI '${package_uri}'`);\n        return;\n      } else if (pkg == package_uri) {\n        package_uri = 'default channel';\n      }\n\n      if (pkg in loadedPackages) {\n        if (package_uri != loadedPackages[pkg]) {\n          console.error(`URI mismatch, attempting to load package ` +\n                        `${pkg} from ${package_uri} while it is already ` +\n                        `loaded from ${loadedPackages[pkg]}!`);\n          return;\n        }\n      } else if (pkg in toLoad) {\n        if (package_uri != toLoad[pkg]) {\n          console.error(`URI mismatch, attempting to load package ` +\n                        `${pkg} from ${package_uri} while it is already ` +\n                        `being loaded from ${toLoad[pkg]}!`);\n          return;\n        }\n      } else {\n        console.log(`Loading ${pkg} from ${package_uri}`);\n\n        toLoad[pkg] = package_uri;\n        if (packages.hasOwnProperty(pkg)) {\n          packages[pkg].forEach((subpackage) => {\n            if (!(subpackage in loadedPackages) && !(subpackage in toLoad)) {\n              queue.push(subpackage);\n            }\n          });\n        } else {\n          console.error(`Unknown package '${pkg}'`);\n        }\n      }\n    }\n\n    self.pyodide._module.locateFile = (path) => {\n      // handle packages loaded from custom URLs\n      let pkg = path.replace(/\\.data$/, \"\");\n      if (pkg in toLoad) {\n        let package_uri = toLoad[pkg];\n        if (package_uri != 'default channel') {\n          return package_uri.replace(/\\.js$/, \".data\");\n        };\n      };\n      return baseURL + path;\n    };\n\n    let promise = new Promise((resolve, reject) => {\n      if (Object.keys(toLoad).length === 0) {\n        resolve('No new packages to load');\n        return;\n      }\n\n      const packageList = Array.from(Object.keys(toLoad)).join(', ');\n      if (messageCallback !== undefined) {\n        messageCallback(`Loading ${packageList}`);\n      }\n\n      // monitorRunDependencies is called at the beginning and the end of each\n      // package being loaded. We know we are done when it has been called\n      // exactly \"toLoad * 2\" times.\n      var packageCounter = Object.keys(toLoad).length * 2;\n\n      self.pyodide._module.monitorRunDependencies = () => {\n        packageCounter--;\n        if (packageCounter === 0) {\n          for (let pkg in toLoad) {\n            self.pyodide.loadedPackages[pkg] = toLoad[pkg];\n          }\n          delete self.pyodide._module.monitorRunDependencies;\n          self.removeEventListener('error', windowErrorHandler);\n          if (!isFirefox) {\n            preloadWasm().then(() => {resolve(`Loaded ${packageList}`)});\n          } else {\n            resolve(`Loaded ${packageList}`);\n          }\n        }\n      };\n\n      // Add a handler for any exceptions that are thrown in the process of\n      // loading a package\n      var windowErrorHandler = (err) => {\n        delete self.pyodide._module.monitorRunDependencies;\n        self.removeEventListener('error', windowErrorHandler);\n        // Set up a new Promise chain, since this one failed\n        loadPackagePromise = new Promise((resolve) => resolve());\n        reject(err.message);\n      };\n      self.addEventListener('error', windowErrorHandler);\n\n      for (let pkg in toLoad) {\n        let scriptSrc;\n        let package_uri = toLoad[pkg];\n        if (package_uri == 'default channel') {\n          scriptSrc = `${baseURL}${pkg}.js`;\n        } else {\n          scriptSrc = `${package_uri}`;\n        }\n        loadScript(scriptSrc, () => {}, () => {\n          // If the package_uri fails to load, call monitorRunDependencies twice\n          // (so packageCounter will still hit 0 and finish loading), and remove\n          // the package from toLoad so we don't mark it as loaded.\n          console.error(`Couldn't load package from URL ${scriptSrc}`)\n          let index = toLoad.indexOf(pkg);\n          if (index !== -1) {\n            toLoad.splice(index, 1);\n          }\n          for (let i = 0; i < 2; i++) {\n            self.pyodide._module.monitorRunDependencies();\n          }\n        });\n      }\n\n      // We have to invalidate Python's import caches, or it won't\n      // see the new files. This is done here so it happens in parallel\n      // with the fetching over the network.\n      self.pyodide.runPython('import importlib as _importlib\\n' +\n                             '_importlib.invalidate_caches()\\n');\n    });\n\n    return promise;\n  };\n\n  let loadPackage = (names, messageCallback) => {\n    /* We want to make sure that only one loadPackage invocation runs at any\n     * given time, so this creates a \"chain\" of promises. */\n    loadPackagePromise =\n        loadPackagePromise.then(() => _loadPackage(names, messageCallback));\n    return loadPackagePromise;\n  };\n\n  ////////////////////////////////////////////////////////////\n  // Fix Python recursion limit\n  function fixRecursionLimit(pyodide) {\n    // The Javascript/Wasm call stack may be too small to handle the default\n    // Python call stack limit of 1000 frames. This is generally the case on\n    // Chrom(ium), but not on Firefox. Here, we determine the Javascript call\n    // stack depth available, and then divide by 50 (determined heuristically)\n    // to set the maximum Python call stack depth.\n\n    let depth = 0;\n    function recurse() {\n      depth += 1;\n      recurse();\n    }\n    try {\n      recurse();\n    } catch (err) {\n      ;\n    }\n\n    let recursionLimit = depth / 50;\n    if (recursionLimit > 1000) {\n      recursionLimit = 1000;\n    }\n    pyodide.runPython(\n        `import sys; sys.setrecursionlimit(int(${recursionLimit}))`);\n  };\n\n  ////////////////////////////////////////////////////////////\n  // Rearrange namespace for public API\n  let PUBLIC_API = [\n    'globals',\n    'loadPackage',\n    'loadedPackages',\n    'pyimport',\n    'repr',\n    'runPython',\n    'runPythonAsync',\n    'checkABI',\n    'version',\n    'autocomplete',\n  ];\n\n  function makePublicAPI(module, public_api) {\n    var namespace = {_module : module};\n    for (let name of public_api) {\n      namespace[name] = module[name];\n    }\n    return namespace;\n  }\n\n  ////////////////////////////////////////////////////////////\n  // Loading Pyodide\n  let wasmURL = `${baseURL}pyodide.asm.wasm`;\n  let Module = {};\n  self.Module = Module;\n\n  Module.noImageDecoding = true;\n  Module.noAudioDecoding = true;\n  Module.noWasmDecoding = true;\n  Module.preloadedWasm = {};\n  let isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\n  let wasm_promise;\n  if (WebAssembly.compileStreaming === undefined) {\n    wasm_promise = fetch(wasmURL)\n                       .then(response => response.arrayBuffer())\n                       .then(bytes => WebAssembly.compile(bytes));\n  } else {\n    wasm_promise = WebAssembly.compileStreaming(fetch(wasmURL));\n  }\n\n  Module.instantiateWasm = (info, receiveInstance) => {\n    wasm_promise.then(module => WebAssembly.instantiate(module, info))\n        .then(instance => receiveInstance(instance));\n    return {};\n  };\n\n  Module.checkABI = function(ABI_number) {\n    if (ABI_number !== parseInt('1')) {\n      var ABI_mismatch_exception =\n          `ABI numbers differ. Expected 1, got ${ABI_number}`;\n      console.error(ABI_mismatch_exception);\n      throw ABI_mismatch_exception;\n    }\n    return true;\n  };\n\n  Module.autocomplete =\n      function(path) {\n    var pyodide_module = Module.pyimport(\"pyodide\");\n    return pyodide_module.get_completions(path);\n  }\n\n      Module.locateFile = (path) => baseURL + path;\n  var postRunPromise = new Promise((resolve, reject) => {\n    Module.postRun = () => {\n      delete self.Module;\n      fetch(`${baseURL}packages.json`)\n          .then((response) => response.json())\n          .then((json) => {\n            fixRecursionLimit(self.pyodide);\n            self.pyodide.globals =\n                self.pyodide.runPython('import sys\\nsys.modules[\"__main__\"]');\n            self.pyodide = makePublicAPI(self.pyodide, PUBLIC_API);\n            self.pyodide._module.packages = json;\n            if (self.iodide !== undefined) {\n              // Perform some completions immediately so there isn't a delay on\n              // the first call to autocomplete\n              self.pyodide.runPython('import pyodide');\n              self.pyodide.runPython('pyodide.get_completions(\"\")');\n            }\n            resolve();\n          });\n    };\n  });\n\n  var dataLoadPromise = new Promise((resolve, reject) => {\n    Module.monitorRunDependencies =\n        (n) => {\n          if (n === 0) {\n            delete Module.monitorRunDependencies;\n            resolve();\n          }\n        }\n  });\n\n  Promise.all([ postRunPromise, dataLoadPromise ]).then(() => resolve());\n\n  const data_script_src = `${baseURL}pyodide.asm.data.js`;\n  loadScript(data_script_src, () => {\n    const scriptSrc = `${baseURL}pyodide.asm.js`;\n    loadScript(scriptSrc, () => {\n      // The emscripten module needs to be at this location for the core\n      // filesystem to install itself. Once that's complete, it will be replaced\n      // by the call to `makePublicAPI` with a more limited public API.\n      self.pyodide = pyodide(Module);\n      self.pyodide.loadedPackages = new Array();\n      self.pyodide.loadPackage = loadPackage;\n    }, () => {});\n  }, () => {});\n\n  ////////////////////////////////////////////////////////////\n  // Iodide-specific functionality, that doesn't make sense\n  // if not using with Iodide.\n  if (self.iodide !== undefined) {\n    // Load the custom CSS for Pyodide\n    let link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.type = 'text/css';\n    link.href = `${baseURL}renderedhtml.css`;\n    document.getElementsByTagName('head')[0].appendChild(link);\n\n    // Add a custom output handler for Python objects\n    self.iodide.addOutputRenderer({\n      shouldRender : (val) => {\n        return (typeof val === 'function' &&\n                pyodide._module.PyProxy.isPyProxy(val));\n      },\n\n      render : (val) => {\n        let div = document.createElement('div');\n        div.className = 'rendered_html';\n        var element;\n        if (val._repr_html_ !== undefined) {\n          let result = val._repr_html_();\n          if (typeof result === 'string') {\n            div.appendChild(new DOMParser()\n                                .parseFromString(result, 'text/html')\n                                .body.firstChild);\n            element = div;\n          } else {\n            element = result;\n          }\n        } else {\n          let pre = document.createElement('pre');\n          pre.textContent = val.toString();\n          div.appendChild(pre);\n          element = div;\n        }\n        return element.outerHTML;\n      }\n    });\n  }\n});\nlanguagePluginLoader\n"]},"metadata":{},"sourceType":"module"}